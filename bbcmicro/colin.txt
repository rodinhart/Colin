REM http://www.6502.org/tutorials/6502opcodes.html
REM https://bbcmic.ro/

LINK = 0
FLAGS = 2
NAME = 4
CODEWORD = 6
PARAMS = 8

ip% = &70 : REM could be another VARIABLE
indirect% = &72
temp% = &74
arg% = &76
stdin% = &78

DIM sp% 511

DIM code% 4095
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.boot%
  LDY #0
.boot_loop%
  LDA core%, Y
  BMI boot_end%

  JSR create%

  LDA core%, Y
  INY
  STA arg%
  LDA #0
  STA arg% + 1
  JSR comma% ; flags

  TYA
  CLC
  ADC #core% AND &FF
  STA arg%
  LDA #0
  ADC #core% DIV 256
  STA arg% + 1
  JSR comma% ; word

.boot_word%
  LDA core%, Y
  INY
  CMP #33
  BCS boot_word%

  LDA core%, Y
  INY
  STA arg%
  LDA core%, Y
  INY
  STA arg% + 1
  JSR comma% ; codeword
  JMP boot_loop%

.boot_end%
  RTS

.comma%
  TYA : PHA
  LDA here% + PARAMS
  STA temp%
  CLC
  ADC #2
  STA here% + PARAMS
  LDA here% + PARAMS + 1
  STA temp% + 1
  ADC #0
  STA here% + PARAMS + 1

  LDA arg%
  LDY #0
  STA (temp%), Y
  LDA arg% + 1
  INY
  STA (temp%), Y

  PLA : TAY
  RTS

.compile%
  LDY #0
  LDA (stdin%), Y
  BNE compile_continue%
  RTS

.compile_continue%
  JSR find%
  LDA arg%
  BNE compile_word%
  LDA arg% + 1
  BNE compile_word%

  LDA #(lit% + CODEWORD) AND &FF
  STA arg%
  LDA #(lit% + CODEWORD) DIV 256
  STA arg% + 1
  JSR comma%

  JSR number% ; compile number
  JSR comma%
  JSR word% ; skip number
  JMP compile%

.compile_word%
  LDY #FLAGS
  LDA (arg%), Y
  CMP #1
  BEQ compile_immediate%

  LDA #CODEWORD
  CLC
  ADC arg%
  STA arg%
  LDA #0
  ADC arg% + 1
  STA arg% + 1
  JSR comma%
  JSR word%
  JMP compile%

.compile_immediate%
  JSR word%

  LDA arg%
  CLC
  ADC #CODEWORD
  STA indirect%
  LDA arg% + 1
  ADC #0
  STA indirect% + 1

  LDY #0
  LDA (indirect%), Y
  STA temp%
  INY
  LDA (indirect%), Y
  STA temp% + 1

  JSR compile_jump%
  JMP compile%
.compile_jump%
  JMP (temp%)

.create%
  LDA latest% + PARAMS
  STA arg%
  LDA latest% + PARAMS + 1
  STA arg% + 1

  LDA here% + PARAMS
  STA latest% + PARAMS
  LDA here% + PARAMS + 1
  STA latest% + PARAMS + 1

  JMP comma% ; link

.Hex%
  EQUS "0123456789ABCDEF"
.dumpAddress%
  LDA #ASC "&"
  JSR &FFE3

  LDA temp% + 1
  LSR A : LSR A : LSR A : LSR A
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp% + 1
  AND #&F
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp%
  LSR A : LSR A : LSR A : LSR A
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp%
  AND #&F
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA #ASC " "
  JMP &FFE3

.find%
  TYA : PHA
  LDA latest% + PARAMS
  STA arg%
  LDA latest% + PARAMS + 1
  STA arg% + 1
.find_loop%
  LDA arg% ; could move null check to end (assuming at least singleton list)
  BNE find_continue%
  LDA arg% + 1
  BNE find_continue%
  PLA : TAY
  RTS

.find_continue%
  LDY #NAME
  LDA (arg%), Y
  STA temp%
  INY
  LDA (arg%), Y
  STA temp% + 1
  LDY #0
.find_compare%
  LDA (temp%), Y
  CMP (stdin%), Y
  BNE find_next%
  INY
  CMP #33
  BCS find_compare%

  PLA : TAY ; found
  RTS

.find_next% 
  LDY #0 ; not found try next item in list
  LDA (arg%), Y
  PHA
  INY
  LDA (arg%), Y
  STA arg% + 1
  PLA
  STA arg%
  JMP find_loop%

.number%
  TYA : PHA
  LDA #0
  STA arg%
  STA arg% + 1
  LDY #0
.number_loop%
  LDA arg% ; times 2
  ASL A
  STA temp%
  LDA arg% + 1
  ROL A
  STA temp% + 1
  ASL temp% ; times 4
  ROL temp% + 1
  LDA temp% ; times 5
  CLC
  ADC arg%
  STA arg%
  LDA temp% + 1
  ADC arg% + 1
  STA arg% + 1
  ASL arg% ; times 10
  ROL arg% + 1, X

  LDA (stdin%), Y
  SEC
  SBC #ASC "0"
  CLC
  ADC arg%
  STA arg%

  INY
  LDA (stdin%), Y
  CMP #33
  BCS number_loop%

  PLA : TAY
  RTS

.word%
  TYA : PHA
  LDY #0
.word_loop%
  LDA (stdin%), Y
  INY
  CMP #33
  BCS word_loop%

  TYA
  CLC
  ADC stdin%
  STA stdin%
  LDA #0
  ADC stdin% + 1
  STA stdin% + 1

  PLA : TAY
  RTS

.COLON%
  JSR create%

  LDA #0
  STA arg%
  STA arg% + 1
  JSR comma% ; flags

  LDA stdin%
  STA arg%
  LDA stdin% + 1
  STA arg% + 1
  JSR comma% ; name
  JSR word%

  LDA #DOCOL% AND &FF
  STA arg%
  LDA #(DOCOL% DIV 256) AND &FF
  STA arg% + 1
  JSR comma% ; codeword

  JMP NXT%

.COMMA%
  DEX
  LDA sp%, X
  STA arg%
  LDA sp% + 256, X
  STA arg% + 1
  JSR comma%
  JMP NXT%

.DOCOL%
  LDA ip%
  PHA
  LDA ip% + 1
  PHA

  LDA #2
  CLC
  ADC indirect% ; corrupts indirect, which is oke because NEXT does as well
  STA ip%
  LDA #0
  ADC indirect% + 1
  STA ip% + 1

  JMP NXT%

.DOT%
  DEX
  LDA sp%, X
  STA temp%
  LDA sp% + 256, X
  STA temp% + 1
  JSR dumpAddress%
  JMP NXT%

.DUP%
  LDA sp% - 1, X
  STA sp%, X
  LDA sp% + 255, X
  STA sp% + 256, X
  INX
  JMP NXT%

.EXIT%
  PLA
  STA ip% + 1
  PLA
  STA ip%
  JMP NXT%

.FETCH%
  TYA : PHA
  LDA sp% - 1, X
  STA temp%
  LDA sp% + 255, X
  STA temp% + 1
  LDY #0
  LDA (temp%), Y
  STA sp% - 1, X
  INY
  LDA (temp%), Y
  STA sp% + 255, X
  PLA : TAY
  JMP NXT%

.IMMEDIATE%
  LDA here% + PARAMS
  SEC
  SBC #6
  STA temp%
  LDA here% + PARAMS + 1
  SBC #0
  STA temp% + 1
  LDY #0
  LDA (temp%), Y
  ORA #1
  STA (temp%), Y
  JMP NXT%

.LIT%
  LDY #0
  LDA (ip%), Y
  STA sp%, X
  INY
  LDA (ip%), Y
  STA sp% + 256, X
  INX

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  JMP NXT%

.NXT%
  LDA #0
  CMP ip%
  BNE next_continue%
  CMP ip% + 1
  BNE next_continue%
  RTS
.next_continue%
  LDY #0 ; load pointer to codeword
  LDA (ip%), Y
  STA indirect%
  INY
  LDA (ip%), Y
  STA indirect% + 1

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  LDY #0
  LDA (indirect%), Y
  STA temp%
  INY
  LDA (indirect%), Y
  STA temp% + 1

  JMP (temp%)

.PING%
  LDA #ASC "#"
  JSR &FFE3
  JMP NXT%

.PLUS%
  DEX
  CLC
  LDA sp% - 1, X
  ADC sp%, X
  STA sp% - 1, X

  LDA sp% + 255, X
  ADC sp% + 256, X
  STA sp% + 255, X
  JMP NXT%

.QUOTE%
  LDA #(lit% + CODEWORD) AND &FF
  STA arg%
  LDA #(lit% + CODEWORD) DIV 256
  STA arg% + 1
  JSR comma%

  JSR find%
  LDA #CODEWORD
  CLC
  ADC arg%
  STA arg%
  LDA #0
  ADC arg% + 1
  STA arg% + 1

  JMP NXT%

.STORE%
  DEX
  LDA sp%, X
  STA temp%
  LDA sp% + 256, X
  STA temp% + 1
  DEX
  LDA sp%, X
  LDY #0
  STA (temp%), Y
  LDA sp% + 256, X
  INY
  STA (temp%), Y
  JMP NXT%

.SEMICOLON%
  LDA here% + PARAMS
  SEC
  SBC #2
  STA indirect%
  LDA here% + PARAMS + 1
  SBC #0
  STA indirect% + 1
  JMP NXT%

.SUBTRACT%
  DEX
  SEC
  LDA sp% - 1, X
  SBC sp%, X
  STA sp% - 1, X

  LDA sp% + 255, X
  SBC sp% + 256, X
  STA sp% + 255, X
  JMP NXT%

.SWAP%
  LDA sp% - 1, X
  PHA
  LDA sp% - 2, X
  STA sp% - 1, X
  PLA
  STA sp% - 2, X

  LDA sp% + 255, X
  PHA
  LDA sp% + 254, X
  STA sp% + 255, X
  PLA
  STA sp% + 254, X

  JMP NXT%

.VARIABLE%
  LDA #2 ; advance to params and push on stack
  CLC
  ADC indirect%
  STA sp%, X
  LDA #0
  ADC indirect% + 1
  STA sp% + 256, X
  INX
  JMP NXT%

.ZEROBRANCH%
  DEX
  LDA sp%, X
  BNE zero_branch_no%
  LDA sp% + 256, X
  BNE zero_branch_no%

  LDY #1 ; branch
  LDA (ip%), Y
  PHA
  DEY
  LDA (ip%), Y
  CLC
  ADC ip%
  STA ip%
  PLA
  ADC ip% + 1
  STA ip% + 1
  JMP NXT%
.zero_branch_no%
  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1
  JMP NXT%

.core%
  EQUB 0 : EQUS "+ "         : EQUW PLUS%
  EQUB 0 : EQUS "EXIT "      : EQUW EXIT%
  EQUB 0 : EQUS "DUP "       : EQUW DUP%
  EQUB 1 : EQUS ": "         : EQUW COLON%
  EQUB 1 : EQUS "; "         : EQUW SEMICOLON%
  EQUB 1 : EQUS "IMMEDIATE " : EQUW IMMEDIATE%
  EQUB 0 : EQUS ", "         : EQUW COMMA%
  EQUB 1 : EQUS "' "         : EQUW QUOTE%
  EQUB 0 : EQUS "0BRANCH "   : EQUW ZEROBRANCH%
  EQUB 0 : EQUS "PING "      : EQUW PING%
  EQUB 0 : EQUS "SWAP "      : EQUW SWAP%
  EQUB 0 : EQUS "- "         : EQUW SUBTRACT%
  EQUB 0 : EQUS "@ "         : EQUW FETCH%
  EQUB 0 : EQUS "! "         : EQUW STORE%
  EQUB 0 : EQUS ". "         : EQUW DOT%
  EQUB &80

.colin%
  EQUS ": IF IMMEDIATE ' 0BRANCH , HERE @ 2 , EXIT ; "
  EQUS ": THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! EXIT ; "
  EQUS ": MAIN 0 IF 10 EXIT ; " : EQUB 0

.Here%
  EQUS "HERE "
.Latest%
  EQUS "LATEST "
.Lit%
  EQUS "LIT "
.Main%
  EQUS "MAIN "

.lit%
  EQUW 0
  EQUW 2
  EQUW Lit%
  EQUW LIT%

.latest%
  EQUW lit%
  EQUW 0
  EQUW Latest%
  EQUW VARIABLE%
  EQUW here%

.here%
  EQUW latest% ; link
  EQUW 0 ; flags 1=immediate 2=hidden
  EQUW Here% ; name
  EQUW VARIABLE% ; codeword
  EQUW here% + 10 ; params

]:NEXT
PRINT "Assembled " ;P% - code% " bytes"
PRINT "---"

X% = 0
CALL boot%

compiled% = !(here% + PARAMS) AND &FFFF
PRINT "Compiling to " ;~compiled%

ip%?0 = 0 : ip%?1 = 0

stdin%?0 = colin%
stdin%?1 = colin% DIV 256
r% = USR(compile%)
PRINT ""
PRINT "Result of compile " ;~r%
end% = !(here% + PARAMS) AND &FFFF
PRINT "Compiled " ;end% - compiled% " bytes"
PRINT "---"

stdin%?0 = Main%
stdin%?1 = Main% DIV 256
CALL find%
main% = (!arg% AND &FFFF) + PARAMS - 2

FOR I% = 2 TO 20 STEP 2
val% = main%!I% AND &FFFF
PRINT ;~val% " (";
name% = !(val% - CODEWORD + NAME) AND &FFFF
FOR J% = 0 TO 7
IF name%?J% > 32 AND name%?J% < 128 THEN VDU name%?J% ELSE J% = 1000
NEXT J%
PRINT ;")"
NEXT I%
END

indirect%?0 = main%
indirect%?1 = main% DIV 256
r% = USR(DOCOL%)
PRINT ""
PRINT "Execution " ;~r%
PRINT (sp%?0 + 256 * sp%?256)
