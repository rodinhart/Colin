REM http://www.6502.org/tutorials/6502opcodes.html
REM https://bbcmic.ro/

LINK = 0
FLAGS = 2
NAME = 4
CODEWORD = 6
PARAMS = 8

ip% = &70 : REM could be another VARIABLE
indirect% = &72
temp% = &74
arg% = &76
stdin% = &78

DIM sp% 511

DIM code% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.boot%
  LDY #0
.boot_loop%
  LDA core%, Y
  BEQ boot_end%

  LDA latest% + 8 ; LATEST @
  STA sp%, X
  LDA latest% + 9
  STA sp% + 256, X
  INX

  LDA here% + 8 ; HERE @ LATEST !
  STA latest% + 8
  LDA here% + 9
  STA latest% + 9

  JSR comma% ; link

  LDA #0 ; todo actually use flag
  STA sp%, X
  STA sp% + 256, X
  INX
  JSR comma% ; flags

  LDA #core% AND &FF
  STA sp%, X
  LDA #(core% / 256) AND &FF
  STA sp% + 256, X
  TYA
  CLC
  ADC sp%, X
  STA sp%, X
  LDA #0
  ADC sp% + 256, X
  STA sp% + 256, X
  INX
  JSR comma% ; word

.boot_word%
  LDA core%, Y
  INY
  CMP #33
  BCS boot_word%

  LDA core%, Y
  INY
  STA sp%, X
  LDA core%, Y
  INY
  STA sp% + 256, X
  INX
  JSR comma% ; codeword
  JMP boot_loop%

.boot_end%
  RTS

.comma%
  TYA : PHA
  LDA here% + 8
  STA temp%
  LDA here% + 9
  STA temp% + 1

  DEX
  LDA sp%, X
  LDY #0
  STA (temp%), Y
  LDA sp% + 256, X
  INY
  STA (temp%), Y

  LDA #2
  CLC
  ADC here% + 8
  STA here% + 8
  LDA #0
  ADC here% + 9
  STA here% + 9

  PLA : TAY
  RTS

.compile%
  LDY #0
LDA (stdin%), Y
JSR &FFE3
  LDA (stdin%), Y
  BEQ compile_done%

  JSR find%
  LDA sp% - 1, X ; peek
  BNE compile_word%
  LDA sp% + 255, X
  BNE compile_word%

  LDA #ASC "N"
  JSR &FFE3
  DEX ; discard not found

  LDA stdin% ; compile LIT
  PHA
  LDA stdin% + 1
  PHA
  LDA #Lit% AND &FF
  STA stdin%
  LDA #(Lit% / 256) AND &FF
  STA stdin% + 1
  JSR find%
  PLA
  STA stdin% + 1
  PLA
  STA stdin%
  LDA #CODEWORD
  CLC
  ADC sp% - 1, X
  STA sp% - 1, X
  LDA #0
  ADC sp% + 255, X
  STA sp% + 255, X
  JSR comma%

  JSR NUMBER% ; compile number
  JSR comma%
  JSR word% ; skip number
  JMP compile%

.compile_word%
  LDA #ASC "W"
  JSR &FFE3
  LDA #CODEWORD
  CLC
  ADC sp% - 1, X
  STA sp% - 1, X
  LDA #0
  ADC sp% + 255, X
  STA sp% + 255, X
  JSR comma%
  JSR word%
  JMP compile%

.compile_done%
  JMP NXT%

.DOCOL%
  LDA ip%
  PHA
  LDA ip% + 1
  PHA

  LDA #2
  CLC
  ADC indirect% ; corrupts indirect, which is oke because NEXT does as well
  STA ip%
  LDA #0
  ADC indirect% + 1
  STA ip% + 1

  JMP NXT%

.EXIT%
  LDA #ASC "X"
  JSR &FFE3
  PLA
  STA ip% + 1
  PLA
  STA ip%
  JMP NXT%

.find%
  TYA : PHA
  LDA latest% + 8
  STA arg%
  LDA latest% + 9
  STA arg% + 1
.find_loop%
  LDA arg% ; could move null check to end (assuming at least singleton list)
  BNE find_continue%
  LDA arg% + 1
  BNE find_continue%

  STA sp%, X ; end of linked list
  STA sp% + 256, X
  INX
  PLA : TAY
  JMP NXT%

.find_continue%
  LDY #NAME
  LDA (arg%), Y
  STA temp%
  INY
  LDA (arg%), Y
  STA temp% + 1
  LDY #0
.find_compare%
  LDA (temp%), Y
  CMP (stdin%), Y
  BNE find_next%
  INY
  CMP #33
  BCS find_compare%

  LDA arg% ; found
  STA sp%, X
  LDA arg% + 1
  STA sp% + 256, X
  INX
  PLA : TAY
  JMP NXT%

.find_next% 
  LDY #0 ; not found try next item in list
  LDA (arg%), Y
  PHA
  INY
  LDA (arg%), Y
  STA arg% + 1
  PLA
  STA arg%
  JMP find_loop%

.LIT%
  LDY #0
  LDA (ip%), Y
  STA sp%, X
  INY
  LDA (ip%), Y
  STA sp% + 256, X
  INX

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  JMP NXT%

.NXT%
  LDA #0
  CMP ip%
  BNE next_continue%
  CMP ip% + 1
  BNE next_continue%
  RTS
.next_continue%
  LDY #0
  LDA (ip%), Y
  STA temp%
  INY
  LDA (ip%), Y
  STA temp% + 1

  LDY #0
  LDA (temp%), Y
  STA indirect%
  INY
  LDA (temp%), Y
  STA indirect% + 1

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  JMP (indirect%)

.NUMBER%
  TYA : PHA
  LDA #0
  STA sp%, X
  STA sp% + 256, X
  LDY #0
.number_loop%
  LDA sp%, X ; times 2
  ASL A
  STA temp%
  LDA sp% + 256, X
  ROL A
  STA temp% + 1
  ASL temp% ; times 4
  ROL temp% + 1
  LDA temp% ; times 5
  CLC
  ADC sp%, X
  STA sp%, X
  LDA temp% + 1
  ADC sp% + 256, X
  STA sp% + 256, X
  ASL sp%, X ; times 10
  ROL sp% + 256, X

  LDA (stdin%), Y
  SEC
  SBC #ASC "0"
  CLC
  ADC sp%, X
  STA sp%, X

  INY
  LDA (stdin%), Y
  CMP #33
  BCS number_loop%

  INX
  PLA : TAY
  JMP NXT%


.plus%
  DEX
  LDA sp%, X
  STA temp%
  DEX
  LDA sp%, X
  CLC
  ADC temp%
  STA sp%, X
  INX
  JMP NXT%

.variable%
  LDA indirect%
  CLC
  ADC #2 ; advance to param
  STA sp%, X
  LDA indirect% + 1
  ADC #0
  STA sp% + 256, X
  INX
  JMP NXT%

.word%
  TYA : PHA
  LDY #0
.word_loop%
  LDA (stdin%), Y
  INY
  CMP #33
  BCS word_loop%

  TYA
  CLC
  ADC stdin%
  STA stdin%
  LDA #0
  ADC stdin% + 1
  STA stdin% + 1

  PLA : TAY
  RTS



.core%
.Lit%
  EQUS "LIT " : EQUW LIT%
  EQUS "+ " : EQUW plus%
  EQUS "EXIT " : EQUW EXIT%
  EQUB 0

.colin%
  EQUS "3 4 + EXIT " : EQUB 0

.Here%
  EQUS "HERE "
.Latest%
  EQUS "LATEST "

.here%
  EQUW 0 ; link
  EQUW 0 ; flags 1=immediate
  EQUW Here% ; name
  EQUW variable% ; codeword
  EQUW latest% + 10 ; params

.latest%
  EQUW here%
  EQUW 0
  EQUW Latest%
  EQUW variable%
  EQUW latest%
]:NEXT
PRINT P% - code% " bytes"

X% = 0
CALL boot%

compiled% = !(here% + PARAMS) AND &FFFF
indirect%?0 = compiled% - 2
indirect%?1 = (compiled% - 2) / 256

stdin%?0 = colin%
stdin%?1 = colin% / 256
ip%?0 = 0 : ip%?1 = 0
r% = USR(compile%)
PRINT ""
PRINT "compile " ;~r%

PRINT "compiled " ;~compiled%
ptr% = !compiled% AND &FFFF
PRINT "ptr " ;~ptr%
PRINT "codeword " ;~(!ptr% AND &FFFF)
PRINT "LIT " ;~LIT%

PRINT ~indirect%?1;~indirect%?0
r% = USR(DOCOL%)
PRINT ""
PRINT "docol " ;~r%
PRINT sp%?0