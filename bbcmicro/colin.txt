REM http://www.6502.org/tutorials/6502opcodes.html
REM https://bbcmic.ro/

LINK = 0
FLAGS = 2
NAME = 4
CODEWORD = 6
PARAMS = 8

ip% = &70 : REM could be another VARIABLE
indirect% = &72
temp% = &74
arg% = &76
stdin% = &78

DIM sp% 511

DIM code% 4095
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.boot%
  LDY #0
.boot_loop%
  LDA core%, Y
  BMI boot_end%

  JSR create%

  LDA core%, Y
  INY
  STA arg%
  LDA #0
  STA arg% + 1
  JSR comma% ; flags

  LDA #core% AND &FF
  STA arg%
  LDA #(core% / 256) AND &FF
  STA arg% + 1
  TYA
  CLC
  ADC arg%
  STA arg%
  LDA #0
  ADC arg% + 1
  STA arg% + 1
  JSR comma% ; word

.boot_word%
  LDA core%, Y
  INY
  CMP #33
  BCS boot_word%

  LDA core%, Y
  INY
  STA arg%
  LDA core%, Y
  INY
  STA arg% + 1
  JSR comma% ; codeword
  JMP boot_loop%

.boot_end%
  RTS

.COLON%
  JSR create%

  LDA #0
  STA arg%
  STA arg% + 1
  JSR comma% ; flags

  LDA stdin%
  STA arg%
  LDA stdin% + 1
  STA arg% + 1
  JSR comma% ; name
  JSR word%

  LDA #DOCOL% AND &FF
  STA arg%
  LDA #(DOCOL% / 256) AND &FF
  STA arg% + 1
  JSR comma% ; codeword

  JMP NXT%

.comma%
  TYA : PHA
  LDA here% + PARAMS
  STA temp%
  LDA here% + PARAMS + 1
  STA temp% + 1

  LDA arg%
  LDY #0
  STA (temp%), Y
  LDA arg% + 1
  INY
  STA (temp%), Y

  LDA #2
  CLC
  ADC here% + PARAMS
  STA here% + PARAMS
  LDA #0
  ADC here% + PARAMS + 1
  STA here% + PARAMS + 1

  PLA : TAY
  RTS

.compile%
  LDY #0
  LDA (stdin%), Y
  BNE compile_continue%
  RTS

.compile_continue%
  JSR find%
  LDA sp% - 1, X ; peek
  BNE compile_word%
  LDA sp% + 255, X
  BNE compile_word%

  DEX ; discard not found

  LDA stdin% ; compile LIT
  PHA
  LDA stdin% + 1
  PHA
  LDA #Lit% AND &FF
  STA stdin%
  LDA #(Lit% / 256) AND &FF
  STA stdin% + 1
  JSR find%
  PLA
  STA stdin% + 1
  PLA
  STA stdin%
  DEX
  LDA #CODEWORD
  CLC
  ADC sp%, X
  STA arg%
  LDA #0
  ADC sp% + 256, X
  STA arg% + 1
  JSR comma%

  JSR NUMBER% ; compile number
  DEX
  LDA sp%, X
  STA arg%
  LDA sp% + 256, X
  STA arg% + 1
  JSR comma%
  JSR word% ; skip number
  JMP compile%

.compile_word%
  DEX
  LDA sp%, X
  STA temp%
  LDA sp% + 256
  STA temp% + 1

  LDY #FLAGS
  LDA (temp%), Y
  CMP #1
  BEQ compile_immediate%

  LDA #CODEWORD
  CLC
  ADC temp%
  STA arg%
  LDA #0
  ADC temp% + 1
  STA arg% + 1
  JSR comma%
  JSR word%
  JMP compile%

.compile_immediate%
  JSR word%
  LDY #CODEWORD
  LDA (temp%), Y
  STA indirect%
  INY
  LDA (temp%), Y
  STA indirect% + 1
  JSR compile_jump%
  JMP compile%
.compile_jump%
  JMP (indirect%)

.create%
  LDA latest% + PARAMS ; LATEST @
  STA arg%
  LDA latest% + PARAMS + 1
  STA arg% + 1

  LDA here% + PARAMS ; HERE @ LATEST !
  STA latest% + PARAMS
  LDA here% + PARAMS + 1
  STA latest% + PARAMS + 1

  JMP comma% ; link

.dumpAddress%
  LDA #ASC "&"
  JSR &FFE3

  LDA temp% + 1
  LSR A : LSR A : LSR A : LSR A
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp% + 1
  AND #&F
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp%
  LSR A : LSR A : LSR A : LSR A
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA temp%
  AND #&F
  TAY
  LDA Hex%, Y
  JSR &FFE3

  LDA #ASC " "
  JMP &FFE3

.DOCOL%
  LDA ip%
  PHA
  LDA ip% + 1
  PHA

  LDA #2
  CLC
  ADC indirect% ; corrupts indirect, which is oke because NEXT does as well
  STA ip%
  LDA #0
  ADC indirect% + 1
  STA ip% + 1

  JMP NXT%

.DUP%
  LDA sp% - 1, X
  STA sp%, X
  LDA sp% + 255, X
  STA sp% + 256, X
  INX
  JMP NXT%

.EXIT%
  PLA
  STA ip% + 1
  PLA
  STA ip%
  JMP NXT%

.find%
  TYA : PHA
  LDA latest% + PARAMS
  STA arg%
  LDA latest% + PARAMS + 1
  STA arg% + 1
.find_loop%
  LDA arg% ; could move null check to end (assuming at least singleton list)
  BNE find_continue%
  LDA arg% + 1
  BNE find_continue%

  STA sp%, X ; end of linked list
  STA sp% + 256, X
  INX
  PLA : TAY
  RTS

.find_continue%
  LDY #NAME
  LDA (arg%), Y
  STA temp%
  INY
  LDA (arg%), Y
  STA temp% + 1
  LDY #0
.find_compare%
  LDA (temp%), Y
  CMP (stdin%), Y
  BNE find_next%
  INY
  CMP #33
  BCS find_compare%

  LDA arg% ; found
  STA sp%, X
  LDA arg% + 1
  STA sp% + 256, X
  INX
  PLA : TAY
  RTS

.find_next% 
  LDY #0 ; not found try next item in list
  LDA (arg%), Y
  PHA
  INY
  LDA (arg%), Y
  STA arg% + 1
  PLA
  STA arg%
  JMP find_loop%

.Hex%
  EQUS "0123456789ABCDEF"

.LIT%
  LDY #0
  LDA (ip%), Y
  STA sp%, X
  INY
  LDA (ip%), Y
  STA sp% + 256, X
  INX

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  JMP NXT%

.NUMBER%
  TYA : PHA
  LDA #0
  STA sp%, X
  STA sp% + 256, X
  LDY #0
.number_loop%
  LDA sp%, X ; times 2
  ASL A
  STA temp%
  LDA sp% + 256, X
  ROL A
  STA temp% + 1
  ASL temp% ; times 4
  ROL temp% + 1
  LDA temp% ; times 5
  CLC
  ADC sp%, X
  STA sp%, X
  LDA temp% + 1
  ADC sp% + 256, X
  STA sp% + 256, X
  ASL sp%, X ; times 10
  ROL sp% + 256, X

  LDA (stdin%), Y
  SEC
  SBC #ASC "0"
  CLC
  ADC sp%, X
  STA sp%, X

  INY
  LDA (stdin%), Y
  CMP #33
  BCS number_loop%

  INX
  PLA : TAY
  RTS

.NXT%
  LDA #0
  CMP ip%
  BNE next_continue%
  CMP ip% + 1
  BNE next_continue%
  RTS
.next_continue%
  LDY #0 ; load pointer to codeword
  LDA (ip%), Y
  STA indirect%
  INY
  LDA (ip%), Y
  STA indirect% + 1

  LDA #2
  CLC
  ADC ip%
  STA ip%
  LDA #0
  ADC ip% + 1
  STA ip% + 1

  LDY #0
  LDA (indirect%), Y
  STA temp%
  INY
  LDA (indirect%), Y
  STA temp% + 1

  JMP (temp%)

.plus%
  DEX
  LDA sp%, X
  STA temp%
  DEX
  LDA sp%, X
  CLC
  ADC temp%
  STA sp%, X
  INX
  JMP NXT%

.SEMICOLON%
  LDA here% + PARAMS
  STA indirect%
  LDA here% + PARAMS + 1
  STA indirect% + 1
  LDA indirect%
  SEC
  SBC #2
  STA indirect%
  LDA indirect% + 1
  SBC #0
  STA indirect% + 1
  JMP NXT%


.variable%
  LDA indirect%
  CLC
  ADC #2 ; advance to param
  STA sp%, X
  LDA indirect% + 1
  ADC #0
  STA sp% + 256, X
  INX
  JMP NXT%

.word%
  TYA : PHA
  LDY #0
.word_loop%
  LDA (stdin%), Y
  INY
  CMP #33
  BCS word_loop%

  TYA
  CLC
  ADC stdin%
  STA stdin%
  LDA #0
  ADC stdin% + 1
  STA stdin% + 1

  PLA : TAY
  RTS


.core%
  EQUB 2
.Lit%      EQUS "LIT "  : EQUW LIT%
  EQUB 0 : EQUS "+ "    : EQUW plus%
  EQUB 0 : EQUS "EXIT " : EQUW EXIT%
  EQUB 0 : EQUS "DUP "  : EQUW DUP%
  EQUB 1 : EQUS ": "    : EQUW COLON%
  EQUB 1 : EQUS "; "    : EQUW SEMICOLON%
  EQUB &80

.colin%
  EQUS ": DOUBLE DUP + EXIT ; 4 DOUBLE EXIT " : EQUB 0

.Here%
  EQUS "HERE "
.Latest%
  EQUS "LATEST "

.here%
  EQUW 0 ; link
  EQUW 0 ; flags 1=immediate
  EQUW Here% ; name
  EQUW variable% ; codeword
  EQUW latest% + 10 ; params

.latest%
  EQUW here%
  EQUW 0
  EQUW Latest%
  EQUW variable%
  EQUW latest%
]:NEXT
PRINT "Assembled " ;P% - code% " bytes"
PRINT "---"

X% = 0
CALL boot%

compiled% = !(here% + PARAMS) AND &FFFF
PRINT "Compiling to " ;~compiled%
indirect%?0 = compiled% - 2
indirect%?1 = (compiled% - 2) / 256

stdin%?0 = colin%
stdin%?1 = colin% / 256
r% = USR(compile%)
PRINT ""
PRINT "Result of compile " ;~r%
end% = !(here% + PARAMS) AND &FFFF
PRINT "Compiled " ;end% - compiled% " bytes"
PRINT "---"

ip%?0 = 0 : ip%?1 = 0
r% = USR(DOCOL%)
PRINT ""
PRINT "Execution " ;~r%
PRINT sp%?0
