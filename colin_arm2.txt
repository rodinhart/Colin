OS_WriteN = &46 : OS_BinaryToDecimal = &28 : OS_WriteI = &100 : OS_ReadUnsigned = &21 : OS_Byte = &06 : OS_WriteC = &00
pc = 15 : lr = 14 : sp = 13 : ds = 12 : ip = 11 : en = 10 : in = 9
LINK% = 0 : NAME% = 4 : CODEWORD% = 12 : FLAGS% = 16 : PARAMS% = 20

DIM code% 4095
DIM datastack% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.input%
 DCB ": IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ; "
 DCB ": THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ; "
 DCB ": ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ; "

 DCB ": BEGIN IMMEDIATE HERE @ ; "
 DCB ": WHILE IMMEDIATE ' 0BRANCH , HERE @ 0 , ; "
 DCB ": REPEAT IMMEDIATE SWAP  ' BRANCH ,  HERE @ - ,  DUP HERE @ SWAP - SWAP ! ; "

 DCB "( allocate space for 30 stars ) "
 DCB "VARIABLE stars ALLOT 360 "

 DCB ": MAIN "
 DCB "( setup x, y, and speed ) "
 DCB "stars 0 BEGIN DUP 30 < WHILE "
 DCB "SWAP "
 DCB "255 RAND OVER ! 4 + "
 DCB "255 RAND OVER ! 4 + "
 DCB "1 3 RAND + OVER ! 4 + "
 DCB "SWAP 1 + REPEAT DROP "

 DCB "( render loop ) "
 DCB "0 BEGIN DUP 300 < WHILE "
 DCB "WAIT CLS "

 DCB "stars 0 BEGIN DUP 30 < WHILE "
 DCB "SWAP "
 DCB "DUP @ OVER 4 + @ 2 PICK 8 + @ "
 DCB "DUP 2 < IF DROP 21 ELSE 3 < IF 42 ELSE 63 THEN THEN "
 DCB "PIXEL "
 DCB "DUP @ OVER 8 + @ + DUP 320 SWAP < IF 320 - THEN OVER ! "
 DCB "12 + "
 DCB "SWAP 1 + REPEAT DROP DROP "

 DCB "1 + REPEAT DROP "

 DCB "; "
.input_end%
 ALIGN

.ds_addr%
 DCD datastack%
.boot%
 stmfd (sp)!, { lr }
 ldr ds, ds_addr%
 adr r0, input%
 adr r1, input_end%
 bl compile%
 ldmfd (sp)!, { lr }
 ldr en, LATEST% + PARAMS%
.run_immediate%  ;; resumes at lr
 str en, run_prog%
 mov ip, #0
 stmfd (sp)!, { ip }
 adr ip, run_prog%
 b next%
.run_prog%
 DCD EXIT% : DCD EXIT%

.compile%
 stmfd (sp)!, { lr }
 mov in, r0
 mov r7, r1
.compile_loop%
 bl word%
 mov r8, r0
 bl find%
 teq r0, #0
 beq compile_int%
 mov en, r0
 ldr r0, [en, #FLAGS%]
 tst r0, #1
 adrne lr, compile_next%
 bne run_immediate%

 ldr r0, HERE% + PARAMS%  ; append codeword
 str en, [r0], #4
 str r0, HERE% + PARAMS%
 b compile_next%

.compile_int%
 mov r0, r8
 bl number%
 ldr r1, HERE% + PARAMS%
 adr r2, LIT%
 str r2, [r1], #4
 str r0, [r1], #4
 str r1, HERE% + PARAMS%

.compile_next%
 cmp in, r7
 blo compile_loop%
 ldmfd (sp)!, { pc }

.number%
 mov r1, r0
 mov r0, #10
 swi OS_ReadUnsigned
 mov r0, r2
 mov pc, lr

.word%
 mov r0, in
.word_loop%
 ldrb r1, [in], #1
 cmp r1, #32
 bhi word_loop%
.word_ws%
 ldrb r1, [in]
 cmp r1, #32
 addls in, in, #1
 bls word_ws%
 mov pc, lr

.find%
 stmfd (sp)!, { lr }
 mov r5, r0
 ldr r6, LATEST% + PARAMS%
.find_loop%
 teq r6, #0
 beq find_done%
 mov r0, r5
 add r1, r6, #NAME%
 bl compare%
 teq r0, #0
 ldrne r6, [r6, #LINK%]
 bne find_loop%
.find_done%
 mov r0, r6
 ldmfd (sp)!, { pc }

.compare%
 add r2, r1, #8
.compare_loop%
 cmp r1, r2
 movhs r0, #0
 bhs compare_end%
 ldrb r3, [r0], #1
 ldrb r4, [r1], #1
 cmp r3, #32
 cmpls r4, #32
 movls r0, #0
 bls compare_end%
 cmp r3, r4
 beq compare_loop%
 mvnlo r0, #0
 movhi r0, #1
.compare_end%
 mov pc, lr

.docol%
 stmfd (sp)!, { ip }
 add ip, en, #PARAMS%
.next%
 ldr en, [ip], #4
 ldr pc, [en, #CODEWORD%]

.LIT%
 DCD STORE% : DCB "LIT     " : DCD lit% : DCD 2
.lit%
 ldr r0, [ip], #4
 stmea (ds)!, { r0 }
 b next%

.STORE%
 DCD TICK% : DCB "!       " : DCD store% : DCD 0
.store%
 ldmea (ds)!, { r0, r1 }
 str r0, [r1]
 b next%

.TICK%
 DCD PAREN% : DCB "'       " : DCD tick% : DCD 1
.tick%
 stmfd (sp)!, { lr }
 bl word%
 bl find%
 ldmfd (sp)!, { lr }
 mov r2, r0
 ldr r0, HERE% + PARAMS%
 adr r1, LIT%
 str r1, [r0], #4
 str r2, [r0], #4
 str r0, HERE% + PARAMS%
 b next%

.PAREN%
 DCD PLUS% : DCB "(       " : DCD paren% : DCD 1
.paren%
 ldrb r0, [in], #1
 teq r0, #ASC ")"
 bne paren%
.paren_ws%
 ldrb r0, [in]
 cmp r0, #32
 addls in, in, #1
 bls paren_ws%
 b exit%

.PLUS%
 DCD COMMA% : DCB "+       " : DCD plus% : DCD 0
.plus%
 ldmea (ds)!, { r0, r1 }
 add r0, r0, r1
 stmea (ds)!, { r0 }
 b next%

.COMMA%
 DCD MINUS% : DCB ",       " : DCD comma% : DCD 0
.comma%
 ldmea (ds)!, { r0 }
 ldr r1, HERE% + PARAMS%
 str r0, [r1], #4
 str r1, HERE% + PARAMS%
 b next%

.MINUS%
 DCD DOT% : DCB "-       " : DCD minus% : DCD 0
.minus%
 ldmea (ds)!, { r0, r1 }
 sub r0, r0, r1
 stmea (ds)!, { r0 }
 b next%

.DOT%
 DCD BRANCH0% : DCB ".       " : DCD dot% : DCD 0
.dot%
 ldmea (ds)!, { r0 }
 adr r1, buf%
 mov r2, #16
 swi OS_BinaryToDecimal
 adr r0, buf%
 mov r1, r2
 swi OS_WriteN
 swi OS_WriteI + 32
 b next%
.buf%
 DCD 0 : DCD 0 : DCD 0 : DCD 0

.BRANCH0%
 DCD COLON% : DCB "0BRANCH " : DCD branch0% : DCD 2
.branch0%
 ldr r0, [ip], #4
 ldmea (ds)!, { r1 }
 teq r1, #0
 subeq ip, ip, #4
 addeq ip, ip, r0
 b next%

.COLON%  ;  CREATE docol% , 0 ,
 DCD CREATE% : DCB ":       " : DCD docol% : DCD 1
 DCD CREATE%
 DCD LIT% : DCD docol% : DCD COMMA%
 DCD LIT% : DCD 0 : DCD COMMA%
 DCD EXIT%

.CREATE%  ; LATEST @ HERE @ LATEST ! , WORD WORD2WORDS , ,
 DCD SEMICOLON% : DCB "CREATE  " : DCD docol% : DCD 1
 DCD LATEST% : DCD FETCH% : DCD HERE% : DCD FETCH% : DCD LATEST% : DCD STORE% : DCD COMMA%
 DCD WORD% : DCD WORD2WORDS% : DCD COMMA% : DCD COMMA%
 DCD EXIT%

.SEMICOLON%  ;  ' EXIT , ;
 DCD LESSTHAN% : DCB ";       " : DCD docol% : DCD 1
 DCD LIT% : DCD EXIT% : DCD COMMA% : DCD EXIT%

.LESSTHAN%
 DCD FETCH% : DCB "<       " : DCD lessthan% : DCD 0
.lessthan%
 ldmea (ds)!, { r0, r1 }
 cmp r0, r1
 movlt r0, #1
 movge r0, #0
 stmea (ds)!, { r0 }
 b next%

.FETCH%
 DCD ALLOT% : DCB "@       " : DCD fetch% : DCD 0
.fetch%
 ldmea (ds)!, { r0 }
 ldr r0, [r0]
 stmea (ds)!, { r0 }
 b next%

.ALLOT%
 DCD ANd% : DCB "ALLOT   " : DCD allot% : DCD 1
.allot%
 stmfd (sp)!, { lr }
 bl word%
 bl number%
 ldmfd (sp)!, { lr }
 ldr r1, HERE% + PARAMS%
 add r1, r1, r0
 str r1, HERE% + PARAMS%
 b next%

.ANd%
 DCD BRANCH% : DCB "AND     " : DCD and% : DCD 0
.and%
 ldmea (ds)!, { r0, r1 }
 and r0, r0, r1
 stmea (ds)!, { r0 }
 b next%

.BRANCH%
 DCD CLs% : DCB "BRANCH  " : DCD branch% : DCD 2
.branch%
 ldr r0, [ip]
 add ip, ip, r0
 b next%

.CLs%
 DCD DROP% : DCB "CLS     " : DCD cls% : DCD 0
.cls%
 SWI OS_WriteI + 12
 b next%

.DROP%
 DCD DUP% : DCB "DROP    " : DCD drop% : DCD 0
.drop%
 sub ds, ds, #4
 b next%

.DUP%
 DCD EXIT% : DCB "DUP     " : DCD dup% : DCD 0
.dup%
 ldr r0, [ds, #-4]
 str r0, [ds], #4
 b next%

.EXIT%
 DCD HERE% : DCB "EXIT    " : DCD exit% : DCD 2
.exit%
 ldmfd (sp)!, { ip }
 teq ip, #0
 bne next%
 mov pc, lr

.HERE%
 DCD IMMEDIATE% : DCB "HERE    " : DCD var% : DCD 0 : DCD end%

.IMMEDIATE%
 DCD LATEST% : DCB "IMMEDIAT" : DCD immediate% : DCD 1
.immediate%
 ldr r1, HERE% + PARAMS%
 ldr r0, [r1, #-4]
 orr r0, r0, #1
 str r0, [r1, #-4]
 b next%

.LATEST%
 DCD OVER% : DCB "LATEST  " : DCD var% : DCD 0 : DCD LIT%

.OVER%
 DCD PICK% : DCB "OVER    " : DCD over% : DCD 0
.over%
 ldr r0, [ds, #-8]
 stmea (ds)!, { r0 }
 b next%

.PICK%
 DCD PIXEL% : DCB "PICK    " : DCD pick% : DCD 0
.pick%
 ldmea (ds)!, { r0 }
 add r0, r0, #1
 ldr r0, [ds, -r0, lsl#2]
 stmea (ds)!, { r0 }
 b next%

.PIXEL%
 DCD RAND% : DCB "PIXEL   " : DCD pixel% : DCD 0
.pixel%
 ldmea (ds)!, { r1, r2, r3 }
 add r2, r2, r2, lsl #2  ; *5
 add r1, r1, r2, lsl #6  ; *64 = *320
 ldr r0, pixel_addr%

 teq r3, #21
 moveq r3, #%00101111
 teq r3, #42
 moveq r3, #%11010011
 teq r3, #63
 moveq r3, #%11111111

 strb r3, [r0, r1]  ; BGGRBRTT

 b next%
.pixel_addr%
 DCD &01FD8000

.RAND%
 DCD SWAp% : DCB "RAND    " : DCD rand% : DCD 0
.rand%  ; Xorshift
 ldmea (ds)!, { r1 }
 ldr r0, rand_seed%
 eor r0, r0, r0, lsl #13
 eor r0, r0, r0, lsr #17
 eor r0, r0, r0, lsl #5
 str r0, rand_seed%
 and r0, r0, r1
 stmea (ds)!, { r0 }
 b next%
.rand_seed% DCD &26294638

.SWAp%
 DCD VARIABLE% : DCB "SWAP    " : DCD swap% : DCD 0
.swap%
 ldmea (ds)!, { r0, r1 }
 mov r2, r0
 stmea (ds)!, { r1, r2 }
 b next%

.VARIABLE%  ;  CREATE var% , 0 , 0 ,
 DCD WAIt% : DCB "VARIABLE" : DCD docol% : DCD 1
 DCD CREATE%
 DCD LIT% : DCD var% : DCD COMMA%
 DCD LIT% : DCD 0 : DCD COMMA%
 DCD LIT% : DCD 0 : DCD COMMA%
 DCD EXIT%
.var%
 add en, en, #PARAMS%
 stmea (ds)!, { en }
 b next%

.WAIt%
 DCD WORD% : DCB "WAIT    " : DCD wait% : DCD 0
.wait%
 mov r0, #19
 swi OS_Byte
 b next%

.WORD%
 DCD WORD2WORDS% : DCB "WORD    " : DCD word2% : DCD 0
.word2%
 stmfd (sp)!, { lr }
 bl word%
 stmea (ds)!, { r0 }
 ldmfd (sp)!, { lr }
 b next%

.WORD2WORDS%
 DCD 0 : DCB "WORD2WOR" : DCD word2words% : DCD 2
.word2words%
 ldmea (ds)!, { r0 }
 ldrb r1, [r0, #7]
 ldrb r2, [r0, #6]
 orr r1, r2, r1, lsl#8
 ldrb r2, [r0, #5]
 orr r1, r2, r1, lsl#8
 ldrb r2, [r0, #4]
 orr r1, r2, r1, lsl#8 

 ldrb r2, [r0, #3]
 ldrb r3, [r0, #2]
 orr r2, r3, r2, lsl#8
 ldrb r3, [r0, #1]
 orr r2, r3, r2, lsl#8
 ldrb r3, [r0, #0]
 orr r2, r3, r2, lsl#8 

 stmea (ds)!, { r1, r2 }
 b next%

.end%
] : NEXT
MODE 13 : OFF : GCOL 0, 63 TINT 192
PRINT ;P% - code% " bytes"
CALL boot%
PRINT
PRINT ;HERE%!PARAMS% - code% " bytes"
END

current% = LATEST%!PARAMS%
WHILE current% <> 0

IF current%!CODEWORD% = docol% THEN
PRINT ": ";
ELSE PRINT "native ";
ENDIF

PROCprn(current% + NAME%)

IF current%!FLAGS% = 1 THEN
PRINT "IMMEDIATE ";
ENDIF

IF current%!CODEWORD% = docol% THEN
params% = current% + PARAMS%
WHILE !params% <> EXIT%
PROCprn((!params%) + NAME%)
params% = params% + 4
IF params%!-4 = LIT% OR params%!-4 = BRANCH0% OR params%!-4 = BRANCH% THEN
PRINT ;!params% " ";
params% = params% + 4
ENDIF
ENDWHILE
PRINT "; ";
ENDIF


PRINT
current% = current%!LINK%
ENDWHILE

END

DEFPROCprn(s%)
LOCAL n%
n% = 8
WHILE ?s% > 32 AND n% > 0
VDU ?s%
s% = s% + 1
n%  = n% - 1
ENDWHILE
VDU 32
ENDPROC