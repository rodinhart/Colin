OS_WriteN = &46 : OS_BinaryToDecimal = &28 : OS_WriteI = &100 : OS_ReadUnsigned = &21
pc = 15 : lr = 14 : sp = 13 : ds = 12 : ip = 11 : en = 10 : in = 9
LINK% = 0 : NAME% = 4 : CODEWORD% = 12 : FLAGS% = 16 : PARAMS% = 20

DIM code% 2047
FOR i% = 0 TO 2047 STEP 4
code%!i% = -1
NEXT
DIM datastack% 1023
FOR p% = 0 TO 2 STEP 2
P% = code%
[OPT p%
.input%
 DCB ": IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ; "
 DCB ": THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ; "
 DCB ": ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ; "
 DCB ": MAIN 0 IF 20 ELSE 30 THEN . ; "
.input_end%
 ALIGN

.ds_addr%
 DCD datastack%
.boot%
 stmfd (sp)!, { lr }
 ldr ds, ds_addr%
 adr r0, input%
 adr r1, input_end%
 stmea (ds)!, { r0, r1 }
 bl compile%
 ldmfd (sp)!, { lr }
 ldr en, LATEST% + PARAMS%
.run_immediate%  ;; resumes at lr
 str en, run_prog%
 mov ip, #0
 adr en, run_prog% - PARAMS%
 b docol%
.run_prog%
 DCD EXIT% : DCD EXIT%


.compile%
 stmfd (sp)!, { r4, r5, in, lr }
 ldmea (ds)!, { r4 }
 ldmea (ds)!, { in }
.compile_loop%
 bl word%
 ldmea (ds)!, { r5 }

 stmea (ds)!, { r5 }
 bl find%

 ldmea (ds)!, { en }
 teq en, #0
 beq compile_int%
 ldr r0, [en, #FLAGS%]
 tst r0, #1
 adrne lr, compile_next%
 bne run_immediate%

 ldr r1, HERE% + PARAMS%  ; append codeword
 str en, [r1], #4
 str r1, HERE% + PARAMS%
 b compile_next%

.compile_int%
 mov r0, #10
 mov r1, r5
 swi OS_ReadUnsigned
 ldr r0, HERE% + PARAMS%
 adr r1, LIT%
 str r1, [r0], #4
 str r2, [r0], #4
 str r0, HERE% + PARAMS%

.compile_next%
 cmp in, r4
 blo compile_loop%

 ldmfd (sp)!, { r4, r5, in, pc }


.word%
 stmea (ds)!, { in }
.word_loop%
 ldrb r0, [in], #1
 cmp r0, #32
 bhi word_loop%
.word_ws%
 ldrb r0, [in]
 cmp r0, #32
 addls in, in, #1
 bls word_ws%
 mov pc, lr

.find%
 stmfd (sp)!, { r4, r5, lr }
 ldmea (ds)!, { r4 }
 ldr r5, LATEST% + PARAMS%
.find_loop%
 teq r5, #0
 beq find_done%
 mov r0, r4
 add r1, r5, #NAME%
 stmea (ds)!, { r0, r1 }
 bl compare%
 ldmea (ds)!, { r0 }
 teq r0, #0
 ldrne r5, [r5, #LINK%]
 bne find_loop%
.find_done%
 stmea (ds)!, { r5 }
 ldmfd (sp)!, { r4, r5, pc }

.compare%
 stmfd (sp)!, { lr }
 ldmea (ds)!, { r0, r1 }
 add lr, r1, #8
.compare_loop%
 cmp r1, lr
 movhs r0, #0
 bhs compare_end%
 ldrb r2, [r0], #1
 ldrb r3, [r1], #1
 cmp r2, #32
 cmpls r3, #32
 movls r0, #0
 bls compare_end%
 cmp r2, r3
 beq compare_loop%
 mvnlo r0, #0
 movhi r0, #1
.compare_end%
 stmea (ds)!, { r0 }
 ldmfd (sp)!, { pc }

.docol%
 stmfd (sp)!, { ip }
 add ip, en, #PARAMS%
.next%
 ldr en, [ip], #4
 ldr pc, [en, #CODEWORD%]


.LATEST%
 DCD HERE% : DCB "LATEST  " : DCD var% : DCD 0 : DCD LATEST%
.var%
 add en, en, #PARAMS%
 stmea (ds)!, { en }
 b next%

.HERE%
 DCD EXIT% : DCB "HERE    " : DCD var% : DCD 0 : DCD end%

.EXIT%
 DCD LIT% : DCB "EXIT    " : DCD exit% : DCD 2
.exit%
 ldmfd (sp)!, { ip }
 teq ip, #0
 bne next%
 mov pc, lr

.LIT%
 DCD DOT% : DCB "LIT     " : DCD lit% : DCD 2
.lit%
 ldr r0, [ip], #4
 stmea (ds)!, { r0 }
 b next%

.DOT%
 DCD DUP% : DCB ".       " : DCD dot% : DCD 0
.dot%
 ldmea (ds)!, { r0 }
 adr r1, buf%
 mov r2, #16
 swi OS_BinaryToDecimal
 adr r0, buf%
 mov r1, r2
 swi OS_WriteN
 swi OS_WriteI + 32
 b next%
.buf%
 DCD 0 : DCD 0 : DCD 0 : DCD 0

.DUP%
 DCD PLUS% : DCB "DUP     " : DCD dup% : DCD 0
.dup%
 ldmea (ds)!, { r0 }
 stmea (ds)!, { r0 }
 stmea (ds)!, { r0 }
 b next%

.PLUS%
 DCD COLON% : DCB "+       " : DCD plus% : DCD 0
.plus%
 ldmea (ds)!, { r0, r1 }
 add r0, r0, r1
 stmea (ds)!, { r0 }
 b next%

.COLON%
 DCD SEMICOLON% : DCB ":       " : DCD colon% : DCD 1
.colon%
 stmfd (sp)!, { lr }
 bl word%
 ldmfd (sp)!, { lr }
 ldr r1, HERE% + PARAMS%
 ldr r0, LATEST% + PARAMS%
 str r1, LATEST% + PARAMS%
 str r0, [r1], #4  ; store LINK
 ldmea (ds)!, { r0 }
 mov r2, #8
.colon_loop%
 ldrb r3, [r0], #1  ; store NAME
 strb r3, [r1], #1
 subs r2, r2, #1
 bne colon_loop%

 adr r0, docol%
 str r0, [r1], #4  ; store CODEWORD
 mov r0, #0
 str r0, [r1], #4  ; store FLAGS
 str r1, HERE% + PARAMS%
 b next%

.SEMICOLON%
 DCD IMMEDIATE% : DCB ";       " : DCD semicolon% : DCD 1
.semicolon%
 adr r0, EXIT%
 ldr r1, HERE% + PARAMS%
 str r0, [r1], #4
 str r1, HERE% + PARAMS%
 b next%

.IMMEDIATE%
 DCD TICK% : DCB "IMMEDIAT" : DCD immediate% : DCD 1
.immediate%
 ldr r1, HERE% + PARAMS%
 ldr r0, [r1, #-4]
 orr r0, r0, #1
 str r0, [r1, #-4]
 b next%

.TICK%
 DCD COMMA% : DCB "'       " : DCD tick% : DCD 1
.tick%
 stmfd (sp)!, { lr }
 bl word%
 bl find%
 ldmfd (sp)!, { lr }
 ldr r0, HERE% + PARAMS%
 adr r1, LIT%
 str r1, [r0], #4
 ldmea (ds)!, { r1 }
 str r1, [r0], #4
 str r0, HERE% + PARAMS%
 b next%

.COMMA%
 DCD BRANCH0% : DCB ",       " : DCD comma% : DCD 0
.comma%
 ldmea (ds)!, { r0 }
 ldr r1, HERE% + PARAMS%
 str r0, [r1], #4
 str r1, HERE% + PARAMS%
 b next%

.BRANCH0%
 DCD MINUS% : DCB "0BRANCH " : DCD branch0% : DCD 2
.branch0%
 ldr r0, [ip], #4
 ldmea (ds)!, { r1 }
 teq r1, #0
 subeq ip, ip, #4
 addeq ip, ip, r0
 b next%

.MINUS%
 DCD SWAp% : DCB "-       " : DCD minus% : DCD 0
.minus%
 ldmea (ds)!, { r0, r1 }
 sub r0, r0, r1
 stmea (ds)!, { r0 }
 b next%

.SWAp%
 DCD FETCH% : DCB "SWAP    " : DCD swap% : DCD 0
.swap%
 ldmea (ds)!, { r0, r1 }
 mov r2, r0
 mov r0, r1
 mov r1, r2
 stmea (ds)!, { r0, r1 }
 b next%

.FETCH%
 DCD STORE% : DCB "@       " : DCD fetch% : DCD 0
.fetch%
 ldmea (ds)!, { r0 }
 ldr r0, [r0]
 stmea (ds)!, { r0 }
 b next%

.STORE%
 DCD BRANCH% : DCB "!       " : DCD store% : DCD 0
.store%
 ldmea (ds)!, { r0, r1 }
 str r0, [r1]
 b next%

.BRANCH%
 DCD 0 : DCB "BRANCH  " : DCD branch% : DCD 2
.branch%
 ldr r0, [ip]
 add ip, ip, r0
 b next%

.end%
] : NEXT
CLS
PRINT ;P% - code% " bytes"
CALL boot%
PRINT

current% = LATEST%!PARAMS%
WHILE current% <> 0

IF current%!CODEWORD% = docol% THEN
PRINT ": ";
ELSE PRINT "native ";
ENDIF

PROCprn(current% + NAME%)

IF current%!FLAGS% = 1 THEN
PRINT "IMMEDIATE ";
ENDIF

IF current%!CODEWORD% = docol% THEN
params% = current% + PARAMS%
WHILE !params% <> EXIT%
PROCprn((!params%) + NAME%)
params% = params% + 4
IF params%!-4 = LIT% OR params%!-4 = BRANCH0% OR params%!-4 = BRANCH% THEN
PRINT ;!params% " ";
params% = params% + 4
ENDIF
ENDWHILE
PRINT "; ";
ENDIF


PRINT
current% = current%!LINK%
ENDWHILE

END

DEFPROCprn(s%)
LOCAL n%
n% = 8
WHILE ?s% > 32 AND n% > 0
VDU ?s%
s% = s% + 1
n%  = n% - 1
ENDWHILE
VDU 32
ENDPROC